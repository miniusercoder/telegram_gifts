# C-shared Go library for Telegram Stars

This project builds a C-shared library **`libtg.so`** (with `libtg.h`) that wraps a Telegram client (via [`gogram`](https://github.com/amarnathcjd/gogram)) to:

- send **Star Gifts** by `@username`
- read your **Stars balance**
- get your own **username**
- validate a **recipient username**

A single global Telegram client is used under the hood.

---

## Features

- C-friendly API (FFI):  
  `Init`, `GetStarsBalance`, `GetMyUsername`, `ValidateRecipient`, `SendGift`
- Uses an existing, already logged-in **session file**
- No updates polling, cache disabled
- Builds via **Docker + Makefile** into `./dist`
- Shared library: `libtg.so` + generated header: `libtg.h`

---

## Build

### Recommended: Docker + Makefile

Prerequisites:

- Docker (BuildKit)
- `make`

Build:

```bash
make build-libtg
````

Result:

* `dist/libtg.so` — shared library (UPX-compressed)
* `dist/libtg.h`  — C header (auto-generated by `-buildmode=c-shared`)

### Manual build (without Docker)

Prerequisites:

* Go (tested with **1.25.4**)
* `gcc`/`clang`
* `CGO_ENABLED=1`, target: Linux/amd64 (or adjust)

Example:

```bash
export CGO_ENABLED=1
export GOOS=linux
export GOARCH=amd64

go build \
  -buildmode=c-shared \
  -o libtg.so \
  -trimpath \
  -buildvcs=false \
  -ldflags "-s -w -buildid="
```

This produces `libtg.so` and `libtg.h` in the current directory.

---

## C API

Include the generated header:

```c
#include "libtg.h"
```

### Functions

```c
// Initialize global Telegram client.
// Must be called once before other functions.
// Returns 0 on success, negative code on error.
int Init(int appId, const char* appHash, const char* sessionFile);

// Returns Stars balance (>= 0) or negative error code.
long long GetStarsBalance(void);

// Returns your username (without '@') as a newly allocated string.
// Empty string on error. Caller must free() the result.
char* GetMyUsername(void);

// Validates that @username is a user (not channel/chat).
// Returns 0 on success, negative error code on failure.
int ValidateRecipient(const char* username);

// Sends a Star Gift.
// giftID  - Star Gift ID (int64)
// hideName - 0 show sender, non-zero hide sender
// Returns 0 on success, negative error code on failure.
int SendGift(const char* username, long long giftID, int hideName);
```

### Error codes

Used by `Init`, `ValidateRecipient`, `SendGift` and as negative return values of `GetStarsBalance`:

| Code | Meaning                       |
| ---: | ----------------------------- |
|    0 | Success                       |
|   -1 | ErrCreateClient               |
|   -2 | ErrStartClient                |
|   -3 | ErrResolveUsername            |
|   -4 | ErrGetPaymentForm / Stars API |
|   -5 | ErrSendStars (payment failed) |
|   -6 | ErrClientNotInitialized       |

---

## Usage overview

1. Create a Telegram API app at [https://my.telegram.org](https://my.telegram.org) to get `appId` and `appHash`.

2. Prepare a **session file** path (e.g. `./session.dat`) with an already logged-in Telegram session (login in CLI by Init() calling).

3. Call:

   ```c
   int rc = Init(APP_ID, "APP_HASH", "./session.dat");
   ```

4. Read your balance:

   ```c
   long long bal = GetStarsBalance();
   if (bal < 0) {
       // handle error
   }
   ```

5. Get your username:

   ```c
   char* me = GetMyUsername();
   // use 'me', then:
   free(me);
   ```

6. Validate a recipient and send a gift:

   ```c
   if (ValidateRecipient("durov") == 0) {
       int rc = SendGift("durov", 987654321LL, 1); // hideName = 1
       // check rc
   }
   ```

Each function that talks to Telegram (`GetStarsBalance`, `GetMyUsername`, `ValidateRecipient`, `SendGift`) internally starts and stops the client for the duration of the call.

---

## Example: Python (ctypes)

Below is a minimal example of loading `libtg.so`, initializing the client, and sending a Star Gift:

```python
import ctypes
from enum import IntEnum
from threading import RLock

init_lock = RLock()
client_lock = RLock()


class ErrorCodes(IntEnum):
    SUCCESS = 0
    CREATE_CLIENT_ERROR = -1
    CONNECT_ERROR = -2
    INVALID_USERNAME = -3
    PAYMENT_FORM_ERROR = -4
    SEND_GIFT_ERROR = -5
    CLIENT_NOT_INITIALIZED = -6


class GiftSender():
    _data_file: str
    initialized = False
    lib = None

    def __init__(
        self,
        api_id: int,
        api_hash: str,
        lib_name: str,
        data_file: str,
    ):
        self._data_file = data_file
        self.lib = ctypes.CDLL(f"./{lib_name}")

        # Установка сигнатур функций
        self.lib.SendGift.argtypes = [ctypes.c_char_p, ctypes.c_int64, ctypes.c_int]
        self.lib.SendGift.restype = ctypes.c_int
        self.lib.ValidateRecipient.argtypes = [ctypes.c_char_p]
        self.lib.ValidateRecipient.restype = ctypes.c_int
        self.lib.Init.argtypes = [ctypes.c_int, ctypes.c_char_p, ctypes.c_char_p]
        self.lib.Init.restype = ctypes.c_int
        self.lib.GetStarsBalance.argtypes = []
        self.lib.GetStarsBalance.restype = ctypes.c_longlong
        self.lib.GetMyUsername.argtypes = []
        self.lib.GetMyUsername.restype = ctypes.c_char_p

        with client_lock:
            init_result = self.lib.Init(
                api_id,
                api_hash.encode("utf-8"),
                data_file.encode("utf-8"),
            )
        print(
            f"[{self._data_file}] Initialization result: {ErrorCodes(init_result).name}"
        )
        # Проверка успешной инициализации
        if init_result != 0:
            print(
                f"[{self._data_file}] Failed to initialize the library: {ErrorCodes(init_result).name}"
            )
            return
        self.initialized = True

    def validate_recipient(self, username: str) -> bool:
        if not self.initialized:
            raise RuntimeError("GiftSender not initialized")
        with client_lock:
            result = self.lib.ValidateRecipient(username.encode("utf-8"))
        if result == ErrorCodes.SUCCESS:
            return True
        elif result == ErrorCodes.INVALID_USERNAME:
            return False
        else:
            print(
                f"[{self._data_file}] Error while validating recipient {username}: {ErrorCodes(result).name}"
            )
            return False

    def send_gift(self, username: str, gift_id: int, anonymous: bool) -> int:
        if not self.initialized:
            raise RuntimeError("GiftSender not initialized")
        try:
            with client_lock:
                sent_result = self.lib.SendGift(
                    username.encode("utf-8"), int(gift_id), int(anonymous)
                )
        except Exception:
            print(
                f"[{self._data_file}] Error while sending gift to {username}"
            )
            return False

        return sent_result

    def get_stars_balance(self) -> int:
        if not self.initialized:
            raise RuntimeError("GiftSender not initialized")
        try:
            with client_lock:
                balance = self.lib.GetStarsBalance()
            return balance
        except Exception:
            print(f"[{self._data_file}] Error while getting stars balance")
            return -1

    def get_my_username(self) -> str:
        if not self.initialized:
            raise RuntimeError("GiftSender not initialized")
        try:
            with client_lock:
                username = self.lib.GetMyUsername()
            return username.decode("utf-8")
        except Exception:
            print(f"[{self._data_file}] Error while getting my username")
            return ""


def get_gift_sender(
    api_id: int, api_hash: string, lib_name: str = "libtg.so", data_file: str = "stars.dat"
) -> GiftSender:
    with init_lock:
        return GiftSender(
            api_id=api_id,
            api_hash=api_hash,
            lib_name=lib_name,
            data_file=data_file,
        )
```

---

## Notes

* **Gift IDs**: you must provide a valid Star Gift ID (listing gifts is out of scope).
* **Session**: only CLI logging performed by first initializing.

* **Thread safety**: the global client is not synchronized; avoid concurrent calls without extra locking.
* **Secrets**: do not commit `appId`, `appHash`, or session files to public repos.
